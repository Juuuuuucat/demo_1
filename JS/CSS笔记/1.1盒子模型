一、盒子模型
    当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的CSS基础框盒模型，将所有元素表示为一个个矩形的盒子。一个盒子由四个部分组成：content、padding、border、margin
    content：即实际内容，显示文本和图像
    padding：内边距，清除内容周围的区域，透明的，取值不能为负，受盒子的background属性影响
    border：边框，围绕内容元素的内边距的一条或多条线，由粗细、颜色、样式三部分组成
    margin：外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域。(区别外边距和内边距是以边框为参照。系统默认外边距为8px)
    在CSS中，盒子模型可以分成:W3C标准盒子模型和IE怪异盒子模型
二、标准盒子模型(浏览器默认的盒子模型)
    盒子总宽度=width+padding+border+margin
    盒子总高度=height+padding+border+margin
    也就是说wigth/height只是内容高度
    标准盒模型占据的实际大小为内容宽高+内边距+边框+外边距
三、IE怪异盒子模型
    盒子总宽度=width+margin
    盒子总宽度=height+margin
    也就是说width/height包含了padding和border
    怪异盒模型占据的实际大小为内容宽高+外边距
四、box-sizing
    CSS中的box-sizing属性定义了引擎如何计算一个元素的总宽度和总高度：
    box-sizing:content-box //默认值，与标准盒子模型表现一致
    box-sizing:border-box //与怪异盒子模型表现一致
    box-sizing:inherit //指定box-sizing属性的值从父元素继承
五、常见定位（布局）方案
    1、普通流（标准流：又称为文档流）
    在普通流中，元素按照在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当前行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也就说，普通流中元素的位置由该元素在HTML文档中的位置决定，是浏览器在渲染显示网页内容时默认采用的一套排版规则。
    浏览器解析行内块或行内标签的时候，如果标签换行书写会产生一个空格的距离。直接利用浮动就没有这个问题。
    2、浮动float
    设置 display: float 属性
    在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移
    （早期浮动用于文字环绕图片）浮动会脱离标准流的控制，在标准流中不占位置；浮动比标准流高半个级别，可以覆盖标准流中的元素（不覆盖内容）；浮动找浮动，也就是下一个浮动元素会在上一个浮动元素的左右浮动；
    浮动后的标签相当于“行内块”元素；
    浮动后的元素不能通过text-align:center和margin：0 auto居中（因为有浮动，浮动优先级更大）
    清除浮动：指的是清除浮动的影响。比如在子级的块级元素都设置了浮动，父级没有设置高度，子级是不会把父级高度给撑开的，而且会对后面的标准流盒子造成影响。但是有些布局不能固定父级元素的高度，比如新闻列表
    清除浮动的方法：
        1、直接给父元素加高度（简单粗暴，方便）
        2、给父元素设置overflow:hidden;（方便）
        3、额外标签法：在父元素内容的最后添加一个块级元素，并给这个块级元素设置clear:both;//清除左右两侧的浮动影响
            缺点：会给页面添加额外的标签，让页面的HTML结构变得复杂
        4、单伪元素清除法：用伪元素替代了额外标签
            .clearfix::after { //clearfix是父元素的类名
                content:'';  //“伪元素”选择器中content属性必须有，不然不生效
                display: block;
                clear: both;
                //补充代码，为了兼容性
                height: 0;
                visibility:hidden;
            }
        5、双伪元素清除法
            .clearfix::before, //用于解决外边距塌陷问题：也叫外边距合并，两个相邻的兄弟或父子关系的块级元素的上下外边距，组合在一起变成单个外边距(左右外边距不存在这样的问题)
            .clearfix::after {
                content:'';
                display: table;
            }
            //真正清除浮动的标签
            .clearfix::after {
                clear:both;
            }
    3、定位position
    可以解决盒子与盒子之间的层叠问题：定位之后的元素层级更高，可以层叠在其他盒子上面
    可以让盒子始终固定在屏幕中的某个位置
步骤：1、设置定位属性position 2、设置偏移值（两个方向，水平[left、right]垂直[top、bottom]各选一个，如果left和right都有，以left为准，top和bottom都有，以top为准）如果没有设置偏移值，就没有效果
        1、相对定位 position:relative;
        相对于自己之前的位置进行移动；但是还是占有原来的位置；标签的显示模式没有改变(还是块级)；没有脱离标准流
        2、绝对定位 position:absolute;
        先找已经定位的父级，（可以相对也可以绝对，一般父相子绝）如果有就以这个父级为参照物进行定位；如果父级没有定位，以浏览器窗口为参照进行定位（“就近”查找定位的父级，逐层向上，都没有就以窗口）
        会改变标签的显示模式（具备行内块特点，如果没有设置宽度也没有内容，盒子的宽度尺寸就是0）
        设置了绝对定位后，就不能使用margin:0 auto居中了
        水平居中：left:50%; + margin-left:-盒子宽度一半px
        垂直居中：top:50%; + margin-top:-盒子高度一半px
        但是如果又需要改盒子大小，上面这些属性也都要改，很麻烦，因此可以用transform:translate(-50%,-50%);

        在绝对定位中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定
        //相对定位relative是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。
        3、固定定位 position:fixed;
        相对于“浏览器窗口”进行定位移动
        脱标，不占位置；具备行内块特点；改变位置相对于浏览器窗口
        4、定位>浮动>标准流(显示优先级)
        默认情况下，定位的盒子，“后来者”在上面，会盖住前面的
        可以设置z-index:整数;取值越大，显示顺序越靠上，默认值为0
        注意z-index必须配合定位才生效
    4、Flex布局
    基于Flex精确灵活控制块级盒子的布局方式，避免浮动布局中脱离文档流现象发生，非常适合结构化布局
    父元素(直接父级)添加display: flex;（弹性容器） 子元素（弹性盒子）可以自动的挤压或拉伸;默认主轴水平，侧轴垂直;弹性盒子都是沿着主轴排列
    在Flex布局模型中，可以使用justify-content属性调节元素在主轴的对齐方式
        center：沿主轴居中(弹性盒子之间没有间距)
        space-between：间距在弹性盒子之间(最左最右没有)
        space-evenly：每个弹性盒子两边都有间距
        space-around：和上面差不多，但是子级之间的距离是和父级间距两倍
    可以使用align-items调节元素在侧轴的对齐方式
        center：沿侧轴居中
        (默认)stretch：拉伸，子级如果没有设置高度，高度铺满父级
    如果想单独设置某一弹性盒子的侧轴对齐方式，则在此弹性盒子中设置属性align-self
        在弹性盒子中设置flex属性，为占用父级剩余尺寸的份数
    使用flex-direction改变元素排列方向
        column：修改主轴方向：列，垂直方向
    有一个问题，如果按上述方法，我设置多个盒子并且设置了宽高，父级设置display: flex; 这些盒子会挤压显示。这时可以设置一个属性实现盒子的换行显示,而不是挤压盒子：flex-wrap: wrap;
        调整行对齐(两行之间，不是盒子之间)方式：align-content(和justify-content取值一样)
    5、grid网格布局
    可以设置行和列将一大块内容分割成一个个小块内容，如果不设置每一行每一列的宽度和高度是多少，会自动的进行平均分配
    grid-template-columns:设置列宽度
    grid-template-rows:设置行高度
    简写：grid-rows:同时设置行和列
    也有justify-content和align-content属性设置里面的排列方式
六、补充样式
    1、浏览器遇到“行内”和“行内块”标签当作文字处理，默认按基线对齐，要想两个按照别的对齐，需要设置vertical-align:middle(居中对齐)/top(顶对齐)/bottom(底部对齐)
    如果一个图像在盒子里，想要水平居中，可以设置盒子的text-align:center;因为当作文字处理
    2、鼠标光标类型cursor
    属性值：defult：默认箭头
            pointer：小手，提示用户可以点击
            text：工字形，提示用户可以选择文字
            move：十字型，表示可以移动
    3、边框圆角 border-radius:n.px/百分比
    赋值规则：从左上角开始，顺时针赋值，没有赋值的看对角。
    常见应用：
        画正圆：盒子设置为正方形，设置border-radius:50%/宽高的一半;
    4、溢出部分显示 overflow:属性值;
        属性值：
        visible 默认值，溢出部分可见
        hidden 溢出部分隐藏
        scroll 无论是否溢出，都显示滚动条(右边和底部都有)
        auto 根据内容自动显示或隐藏滚动条
    5、精灵图
    将多张小图片(图标)合并成一张大图片，这张大图片称为精灵图。
    减少服务器发送次数，减轻服务器压力，提高页面加载速度。就比如有8张小图片要发送，一般要发送8次，但是如果合成一张大图片，发送1次就可以了
    使用步骤：(精灵图标签一般用行内标签span。。。)
        1、创建盒子，盒子尺寸和小图片尺寸相同
        2、将精灵图设置为盒子的背景图片background-image:url(.////);
        3、修改背景图位置background-position:px, px;(往左往上取负值)
    但是精灵图也有一些缺点：
        图片文件还是比较大的；图片本身放大缩小会失真；而且一旦图片制作完毕想要更换也非常复杂
    因此出现了字体图标iconfont(展示的是图标，本质是文字，有文字的属性)也不是完全替代了精灵图，只是对于一些样式简单的小图标，用字体图标
        但是图标库中没有所需的图标怎么办：在iconfont网站上传矢量图生成字体图标
    6、背景图片大小
    background-size:宽度 高度; //如果用百分数，则相对于当前盒子自身的宽高百分比
        contain 包含，等比例缩放，直到高度或宽度和盒子一样，另一个方向会停止缩放，可能会留白
        cover 覆盖，保证宽或高和盒子尺寸完全相同，不留白但是会导致图片显示不全
        工作中，图的比例和盒子比例都是相同的，contain和cover效果一样
    7、盒子阴影box-shadow
    h-shadow 必选 水平偏移量。允许负值
    v-shadow 必选 垂直偏移量。允许负值
    blur 可选 模糊度
    spread 可选 阴影扩大
    color 可选 阴影颜色
    inset 可选 改为内部阴影,注意如果是外阴影不需要加outset，默认的
    8、过渡：让元素的样式慢慢变化，常配合hover使用，增强网页交互体验
    transition:all 1s; // 谁要变化谁加过渡属性,hover里写过渡最后的效果(all表示所有属性，也可以写单个属性width或background-color.....)
    9、平面转换transform
        改变盒子在平面内的形态(位移、旋转、缩放)
        2D转换
        1、位移：transform: translate(水平, 垂直); //取百分比是盒子“自身尺寸”的百分比；如果只给一个值，就表示水平移动距离；translateX() ，如果想只在垂直移动，就用translateY()
            定位后利用位移实现居中transform: translate(-50%, -50%);这个方法也不是万能的，如果后面还有transform实现别的效果，根据层叠性，会覆盖之前的效果
        2、旋转transform: rotate(角度); //单位是deg，正值顺时针，负值逆时针
            默认原点是盒子中心，使用transform-origin:水平,垂直;可以改变原点位置（属性加到要转的那个元素上）
        3、复合转换transform: translate() rotate(); //换位置实现的效果不一样
        4、缩放transform: scale(缩放倍数);
        5、渐变background-image: 
            linear-gradient(
                transparent, //透明色
                rgba(0,0,0,.5)
            );
    10、空间转换transform
    transform: translate3d(x,y,z);
        

