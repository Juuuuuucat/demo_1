1、模块化
    遵守固定的规则，把一个大文件拆成独立并相互依赖的多个小模块。提高了代码的复用性、可维护性，可以实现按需加载。
2、Node.js中根据模块来源不同，分为3大类：
    内置模块：由官方提供的，例如fs、path、http等
    自定义模块：用户创建的.js文件
    第三方模块：由第三方开发出来的，使用前需要先下载
    这些模块都可以通过require()方法加载（注意，使用require方法加载模块时，会执行模块中的代码）
3、模块作用域
    和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制叫做模块作用域。可以防止全局变量污染的问题
    在每个.js自定义模块中都有一个module对象，存储了和当前模块相关的信息。
        当用require方法导入自定义模块时，得到的永远都是module.exports所指的对象，将模块内的成员共享出去，供外界使用。也就是相当于exports属性是对外的接口，加载某个模块，其实是加载该模块的module.exports属性
    还可以简写为exports，默认情况下，exports和module.exports指向同一个(空)对象，可以向里面添加属性（如果改变指向就不一定了）。最终共享的结果，以module.export指向的对象为准。因此为了防止混乱，不要在同一个模块中同时使用module.exports和exports。
4、模块的加载机制
    1、优先从缓存中加载：模块在第一次加载后会被缓存，这也意味着多次调用require()不会导致模块的代码被执行多次
    2、内置模块的加载优先级最高
    3、在加载自定义模块时，前面没有./或../开头，则会当成内置模块或第三方模块进行加载。同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Node.js会按顺序分别尝试加载以下的文件：确切的文件名-->补.js-->补.json-->补.node，都没有就加载失败