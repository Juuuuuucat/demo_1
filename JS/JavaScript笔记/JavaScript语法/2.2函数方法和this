一、方法
    在一个对象的一个属性绑定函数，称为这个对象的方法，调用时使用obj.prop()；方法内部一般都会有一个this关键字,this是一个特殊变量，它始终指向当前对象；（但是如果直接单独调用函数，该函数的this指向全局变量，也就是window；在strict模式下this指向undefined）这里要保证this指向正确，必须用obj.xxx()的形式调用
二、this关键字
    函数的this关键字在JS中的表现略有不同，在严格模式和非严格模式之间也会有一些差别；this的指向在函数定义的时候是确定不了的，只有函数执行时才能确定，一般情况下，this的最终指向的是那个调用它的对象。
    this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象（this就是函数运行时所在的对象/环境）
    1、全局作用域或者普通函数中this指向全局对象window(定时器里面的this也是指向window，因为window可以省略，window.setTimeout；立即执行函数也是window)（在严格模式下指向undefined）
    2、方法调用中，谁调用this指向谁
        包括事件绑定函数中this指向函数调用者，也就是绑定的那个事件对象
    3、构造函数中this指向构造函数的实例对象（原型对象里面的this指向的也是实例对象）
    4、绑定规则
    根据不同的使用场合，this有不同的值，主要分为下面几种情况：
        1. 检查 ' . ' 左边是谁调用这个函数. 例如 xiaoming.age();  age函数里面有this, 然后 '.' 旁边是xiaoming , 那么this就是指向xiaoming了.这种叫做隐式绑定.（对象的方法里包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象会改变this的指向）
        2. 如果点旁边没有,那就检查有没有用到 bind, apply, call 这三种, 有的话就是调用此方法的对象. 这种叫做显式绑定
        3. 如果上面两个都没有,检查代码里面有没有用到new关键字, 构造函数里的this指向新创建的实例对象. 这种叫做new绑定
            new命令的原理：
                1、创建一个空对象，作为将要返回的对象实例
                2、将这个空对象的原型指向构造函数的prototype属性
                3、让this指向这个空对象
                4、开始执行构造函数内部的代码，给这个空对象添加属性和方法
                5、不需要return语句，返回构造的这个新对象

        4. 上面三个都没有, 检查是不是有箭头函数, 有箭头函数的话,那么指向是箭头函数的词法绑定的对象. 就是它的外层调用者(没有外层函数，就绑定到全局对象). 这种叫做词法绑定
        5. 全部都没有（全局环境）,如果不是strict模式那就是window对象了,是strict模式就是 error (undefined).
        new绑定优先级 > 显式绑定优先级 > 隐式绑定优先级 > 默认绑定优先级

三、call()、apply()、bind()
    1、fn.call(thisArg,参数1,2..) 可以改变fn内的this指向，并调用这个函数；主要作用是实现继承.
    2、fn.apply(thisArg,[参数1,2..]) 可以改变fn内的this指向，并调用这个函数；传递的函数参数必须包含在数组中
    3、fn.bind(thisArg,参数1,2..) 可以改变fn内部的this指向，但不会调用这个函数；返回的是原函数改变this后和传入参数后的新函数。
        如果有的函数我们不需要立即调用，但是又想改变这个函数内部this的指向，比如按钮绑定事件函数里面的定时器函数
        从上面看到，三者的区别在于：
            三者都可以改变函数的this对象指向
            三者第一个参数都是this要指向的对象，如果没有这个参数或者为null、undefined，则默认指向全局window
            三者都可以传参，但apply是数组，call和bind是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入
            bind返回绑定this之后的函数，apply、call则是立即执行
四、常见误区
Foo.method = function(){
    function test(){
        //在这里this会被设置为全局对象，而不是指向Foo
    }
    test();
}
因此，为了在test中获取对Foo对象的引用，我们就需要在method函数内部创建一个局部变量指向Foo对象，这样可以保证了this指向
    Foo.method = function(){
        let that = this;
        function test(){
            //在这里使用that，就可以保证指向Foo对象
        }
        test();
    }
另一个误区就是，当我们把一个对象的方法赋值给另一个变量，再调用这个函数，函数内的this将不再指向obj对象
    let test = obj.method;
    test(); //作为普通函数调用