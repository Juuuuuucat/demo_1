一、概念
    高阶函数不仅可以接受函数作为参数，最典型的就是回调函数。还可以把函数作为结果值返回
    闭包：有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁
    第一，闭包是一个函数，而且存在于另一个函数当中
    第二，闭包可以访问到父级函数的变量，且该变量不会销毁，一直存在内存中，供子级函数调用
        function person(){
        var name = '有鱼';
        function cat(){
            console.log(name);
            }
        return cat;
        }
        var per = person();// per的值就是return后的结果，即cat函数
        per();// 有鱼 per()就相当于cat()
        per();// 有鱼 同上，而且变量name没有销毁，一直存在内存中，供函数cat调用
        per();// 有鱼
二、原理
    闭包的实现原理，其实是利用了作用域链的特性，作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。
例如：
    var age = 18;
    function cat(){
        age++;
        console.log(age);//cat函数内输出age,该作用域没有，则向外层寻找，结果找到了
    }
    cat();//19
    cat();//20
    cat();//21
    如果还有其他函数也要用到age的值，则会受到影响，而且全局变量很容易被人修改，比较不安全，所以我们必须解决这个问题，那就是把变量封装到函数内，让它成为局部变量。
    function person(){
        var age = 18;
        function cat(){
            age++;
            console.log(age);
        }
        return cat;
    }
    person()();//19
    person()();//19,每次调用函数person,进入该作用域,age就会重新赋值为18，所以cat的值一直是19，
    var per = person();//per相当于函数cat
    per();//19 即cat() 这样每次调用不再经过age的初始值，就可以一直增加了,而且变量age在函数内部,不易修改和外泄，相对来说比较安全
    per();//20
    per();//21
三、闭包作用
    1：隐藏变量，避免全局污染
    2：可以读取函数内部的变量

同时闭包使用不当，优点就变成了缺点：

    1：导致变量不会被垃圾回收机制回收，造成内存消耗
    为什么使用闭包时变量不会被垃圾回收机制销毁呢，先看JS垃圾回收机制:JS规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可以节省内存；使用闭包时，按照作用域链的特点，闭包外面的变量不会被销毁，因为函数会一直被调用(引用)，所以一直存在，如果闭包使用过多会造成内存销毁。
    2：不恰当的使用闭包可能会造成内存泄漏的问题(内存泄漏见4.1)
四、应用
    借助闭包可以封装一个私有变量，创建计数器
    延长变量的作用范围和生命周期

五、递归
函数内部调用自己，这个函数就是递归函数。由于递归很容易发生“栈溢出”错误，所以必须要加退出条件return
六、循环中的闭包
    for(var i = 0; i < 10; i++) {
        setTimeout(function() {
            console.log(i);  //当log被调用的时候，匿名函数会保持对外部变量i的引用，此时for循环已经结束，i的值被修改为10，因此会输出10十次
        }, 1000);
    } 
    可以使用匿名包装器：
        for(var i = 0; i < 10; i++){
            (function(e){
                setTimeout(function(){
                    console.log(e);
                },1000)
            })(i); //外部的匿名函数会立即执行，将i作为参数传入，这样e就有了i的一个拷贝；当定时器里面的匿名函数执行时，就拥有的对e的引用，e的值不会被循环改变
        }
    更简单的方法是不要用var，用let定义i