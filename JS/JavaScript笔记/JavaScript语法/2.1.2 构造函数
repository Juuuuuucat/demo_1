JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。构造函数的特点有两个：
    函数体内部使用了this关键字，代表了所要生成的对象实例。
    生成对象的时候，必须使用new命令（通过new关键字调用的函数都被认为是构造函数）
    如果new被遗漏了，则函数不会返回新创建的对象
new命令的作用，就是执行构造函数，返回一个实例对象。如果构造函数忘记加new，则构造函数就变成了普通函数，并不会生成实例对象，而且此时this代表全局对象。
    new命令的原理：
    1、创建一个空对象，作为将要返回的实例对象
    2、将这个空对象的原型指向构造函数的prototype属性
    3、让this指向这个空对象
    4、开始执行构造函数内部的代码，给这个空对象添加属性和方法
    5、不需要return语句，隐式的返回构造的这个新对象
也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作都会发生在这个空对象上（构造函数之所以叫“构造函数”，就是操作一个空对象，即this对象，将其“构造”为需要的样子）。
如果构造函数内有return语句，将会影响返回结果
    return后面跟一个对象，new命令会返回return语句指定的对象（如果是数组就返回这个数组）；return后跟普通类型数据，返回构建的对象

    函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。使用这个属性，可以判断函数调用的时候，是否使用new命令。

如果有时我们拿不到构造函数，只有一个现有的对象，我们可以以这个现有的对象作为模板，生成新的实例对象：var newObj = Object.create(obj1);此时newObj继承了obj1的属性和方法。
例如：
    function Star(uanme, age) {
        this.uanme = uname;
        this.age = age;
        this.sing = function(){
            console.log("唱歌")
        }
    }
1、成员：构造函数中的属性和方法称为成员
    实例成员：就是构造函数内部通过this添加的成员，uname、age、sing就是实例成员。实例成员只能通过实例化的对象来访问，不可以通过构造函数来访问，就比如Star.uname 是undefined
    静态成员：在构造函数本身上添加的成员，就比如sex
        Star.sex = '男'; //只能通过构造函数访问，不能通过实例对象访问
        
2、原型：构造函数通过原型分配的函数是所有对象共享的
JS中，每个构造函数都有一个prototype属性，指向原型对象。注意，这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。因此我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。
    Star.prototype.sing = function(){
        //因此一般情况下，公共属性定义到构造函数里面，公共的方法定义到原型对象身上
    };
3、在构造出的实例对象上有自动添加的一个__proto__属性指向构造函数的原型对象；因此在查找方法时，先在实例对象上查找，没有就去原型对象上查找，有就拿来用
4、对象原型(__proto__)和构造函数(prototype)原型对象(这两个其实本身都是一个)里面有一个属性constructor，指回构造函数本身。constructor主要用于记录该对象引用于哪个构造函数。注意，如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动利用constructor指回原来的构造函数。
5、原型对象里面也有一个__proto__属性指向Object原型对象，依次类推，就是一个原型链。
    Star.prototype.__proto__ === Object.prototype，然后Object.prototype.constructor === Object构造函数
6、继承
ES6之前并没有extends继承，都是通过构造函数+原型对象模拟实现继承，称为组合继承
    1、call() 可以调用这个函数，还可以改变this指向
    func.call(thisArg,arg1,arg2..);
        thisArg是当前调用函数要修改的this的指向对象，如果没有这个参数或者为null、undefined，则默认指向全局window；argx是给函数传递的参数
    借用父构造函数继承属性：在子构造函数中 Father.call(this,参数..);这里的this指向子构造函数的对象实例。
    