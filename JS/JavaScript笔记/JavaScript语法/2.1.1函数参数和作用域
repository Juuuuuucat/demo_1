一、函数的定义方式有：
    1、function fn(){} //命名函数；在执行前会被解析(声明提升),因此在函数定义的上面被调用也是对的
    2、let fun = function(){} //匿名函数(函数赋值表达式)
    3、let fun = function bar(){} //将命名函数赋值给变量
    3、let fun = new Function(参数,函数体)
    所有函数都是Function的实例（对象）
二、函数的调用方式：
    1、普通函数 fn(); 或者 fn.call(参数);
    2、对象方法 obj.fun();
    3、构造函数 new Fun();
    4、绑定事件函数 btn.onclick = function(){} 由事件触发调用
    5、定时器函数 setInterval(函数,时间) 每隔一段时间自动调用一次
    6、立即执行函数(function(){//})(); 或者 (function(){}());立即自动调用。立即执行函数最大的作用是 独立创建了一个作用域，里面所有的变量都是局部变量，创建了一个命名空间，避免了命名冲突问题
        (function a(){
            console.log('aaa');
        })(); // 'aaa'
        a(); // Uncaught ReferenceError: a is not defined
1、JS中允许函数传入任意个参数而不影响调用
    传入参数>定义参数：函数会忽略多传入的参数
    传入参数<定义参数：未传入的将收到undefined
2、要避免收到undefined，可以对参数进行检查
    1、arguments：只在函数内部起作用，永远指向当前函数调用者传入的所有参数(尽管在语法上它可以用索引值访问，还有数组相关的属性length，但它不是数组，是对象)。利用arguments可以获得调用者传入的所有参数,即使函数不定义任何参数,还是可以拿到参数的值;常用于判断传入参数的个数
        在函数中，arguments的值可以被修改，相当于将传入的数据改变了，影响最后输出结果
        不管它有没有被使用，arguments对象总会被创建。
    2、剩余参数：只能写在函数参数最后，前面用...再加一个标识符'function(a,b,...rest)',传入的a,b外的多余的参数以“数组”的形式交给变量rest。如果传入的参数连正常定义的参数都没填满，rest参数会接收一个“空数组”
3、扩展运算符：可以将数组拆分成以逗号分隔的参数序列
    let arr = ['a','b','c'];
    console.log(...arr); //就相当于console.log('a','b','c')
    可以应用于数组合并
        let arr1 = [1,2,3];
        let arr2 = [4,5,6];
        let arr3 = [...arr1, ...arr2];
        console.log(arr3); //[1,2,3,4,5,6]
        另一种方法：arr1.push(...arr2);
            console.log(arr1); //[1,2,3,4,5,6]
    还可以将伪数组转换为数组
        let div = document.querySelectorAll('div');
        let rdiv = [...div];

JavaScript引擎有一个在行末自动添加分号的机制，因此要小心你写的多行的return语句

作用域又称上下文,就是变量在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突
1、函数作用域(局部作用域)
    如果一个变量在函数体内部声明，则它的作用域为整个函数体，在函数体外不可引用该变量；如果变量在函数体内没有声明直接赋值，那么它是全局变量。
    如果两个不同的函数各自声明了同一个变量，那么变量只在各自的函数体内起作用，互不影响；
    如果两个函数嵌套，内部函数可以访问外部函数定义的变量，反过来不行；如果外部函数声明的变量和内部函数声明的变量重名，则内部函数变量将'屏蔽'外部函数变量（JS函数在查找变量时从自身函数定义开始，由内向外查找，也就是沿着作用域链查找）
2、块级作用域
    在for循环等语句块中是无法定义具有局部作用域的变量的,为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量。ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。
3、全局作用域（整个script标签，或者是一个单独的js文件）
    不在任何函数内定义或是大括号中声明的的变量都具有全局作用域,全局作用域下声明的变量可以在程序的任意位置访问。JS默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
    以变量方式定义的函数实际上也是一个全局变量
4、词法作用域(静态作用域)
    词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪来决定的。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定
作用域链：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值。 
    当在JS中使用一个变量的时候，首先JS引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域；如果在全局作用域里仍然找不到，它就会在全局范围内隐式声明该变量(非strict模式)或是直接报错
8、变量提升
    JS的函数定义特点，它会先扫描整个函数体语句，把所有声明的变量‘提升’到函数顶部，但不会提升赋值操作
    //是var表达式和function声明都会被提升到当前作用域的顶部

    1、全局变量：在全局作用域下的变量，在全局下都可以使用
    2、局部变量：只能在函数内部使用
        全局变量只有在浏览器关闭的时候才会销毁，而局部变量当我们程序执行完之后就会销毁，比较节约资源
11、预解析
    JS代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：预解析和代码执行。
JS引擎会先把js里面所有的var还有function提升到当前作用域的最前面，然后赋值语句是在代码执行过程中运行的
    1、变量预解析（变量提升）
    把所有的变量声明提升到“当前的作用域”前面，不提升赋值操作（包括函数表达式的变量）
    2、函数预解析（函数提升）
    就是把所有的函数声明提升到当前作用域的最前面，不调用函数
在访问到函数内的某个变量比如foo时，JavaScript会按照下面顺序查找：
    1、当前作用域内是否有var foo的定义；
    2、函数形参中是否有foo；
    3、函数自身是否叫做foo；
    4、到上层作用域再按上面的步骤查找。
一个情况：var a=b=c=9;其实相当于：var a=9; b=9; c=9;三条语句