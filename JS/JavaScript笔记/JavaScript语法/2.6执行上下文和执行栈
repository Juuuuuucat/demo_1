一、执行上下文
是对JS代码执行环境的一种抽象概念，也就是说只要有JS代码运行，那么它就一定是运行在执行上下文中。
    1、全局执行上下文
    这是一个默认的或者说基础的执行上下文(一个程序中只能有一个)所有不在函数中的代码都会在全局执行上下文中执行。会做两件事：创建一个全局的window对象，将this指向这个全局对象
    2、函数执行上下文
    存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文（一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问）
    3、Eval函数执行上下文(很少用不建议用)
    在eval函数中执行的代码会有自己的执行上下文（eval函数容易导致恶意攻击，并且运行代码的速度比相应的替代方法慢）
二、执行上下文的生命周期
    1、创建阶段
    当函数被调用，但未执行任何内部代码之前，做了三件事：绑定this(this的值是在执行的时候才能确认)，创建词法环境(词法环境有两个组成部分，全局环境和函数环境)，创建变量环境(也是一个词法环境，两者的区别在于前者存储函数声明和变量(let和const)绑定，后者仅用于存储变量(var)绑定)
    2、执行阶段
    在这阶段，执行变量赋值、代码执行。如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值
    3、回收阶段
    执行上下文出栈等待虚拟机回收执行上下文
三、执行栈
    也叫调用栈，后进先出。当JS引擎开始执行第一行脚本代码时，它就会创建一个全局执行上下文并压入栈中，每当引擎碰到一个函数，就会创建函数执行上下文并压入栈中。引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束之后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。当所有代码执行完毕，全局上下文也会被推出栈，程序结束。
    
一、JS是单线程
单线程也就是说同一时间只能做一件事-----这是因为JS是为处理页面中用户的交互以及操作DOM而诞生的，比如我们对某个DOM元素进行添加和删除，不能同时进行。单线程就意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务，这样会导致：如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉
二、同步和异步
允许JS脚本创建多个线程。于是JS中出现了同步和异步
同步：前一个任务结束后才能执行后一个任务，程序的执行顺序与任务的排列顺序一致、同步的；
异步：你在做一件事时，因为这件事会花费很长时间，在做这件事的同时，还可以去处理其他事情。本质区别就是这条流水线上各个流程的执行顺序不同
1、同步任务放在主线程执行栈中
2、异步是通过回调函数实现的，一般异步任务有以下三种类型
        ①普通事件 click、resize等
        ②资源加载 load error等
        ③定时器 setTimeout、setInterval
        异步任务相关的回调函数放在任务队列中(也叫消息队列)
JS执行机制：
    1、先执行执行栈中的同步任务
    2、异步任务(回调函数)放入消息队列
    3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是这个异步任务就结束等待状态，进入执行栈中开始执行。
由于主线程不断的重复从消息队列获取任务、执行任务、再获取任务、再执行，所以这种机制称为事件循环
